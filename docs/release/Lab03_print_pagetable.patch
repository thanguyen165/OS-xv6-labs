diff --git a/kernel/exec.c b/kernel/exec.c
index 6d7c452..85eb327 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -128,6 +128,9 @@ exec(char *path, char **argv)
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  if(p->pid == 1)
+    vmprint(p->pagetable);
+
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
diff --git a/kernel/vm.c b/kernel/vm.c
index 7f388fe..6498ebd 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -488,9 +488,35 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 
 
 #ifdef LAB_PGTBL
+void
+print_pgtbl(pagetable_t pagetable, int depth)
+{
+  // there are 2^9 = 512 PTEs in a page table.
+  for(int i=0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if (pte & PTE_V){
+      printf("..");
+      for(int j=0; j<depth; j++){
+        printf(" .."); // print the depth of the page table
+      }
+
+      // must casting to void*, else warning from compiler
+      printf("%d: pte %p pa %p\n", i, (void*)pte, (void*)PTE2PA(pte));
+
+      // check if the PTE is a page table
+      if((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0) {
+        uint64 child = PTE2PA(pte); // get the physical address of the child page table
+        print_pgtbl((pagetable_t)child, depth+1); // recursively print the child page table
+      }
+    }
+  }
+}
+
 void
 vmprint(pagetable_t pagetable) {
   // your code here
+  printf("page table %p\n", pagetable);
+  print_pgtbl(pagetable, 0);
 }
 #endif
 
