diff --git a/conf/lab.mk b/conf/lab.mk
index 278d1a8..2992d87 100644
--- a/conf/lab.mk
+++ b/conf/lab.mk
@@ -1 +1 @@
-LAB=syscall
+LAB=pgtbl
diff --git a/grade-lab-pgtbl b/grade-lab-pgtbl
new file mode 100755
index 0000000..1e5475e
--- /dev/null
+++ b/grade-lab-pgtbl
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+
+import re
+from gradelib import *
+
+r = Runner(save("xv6.out"))
+
+@test(0, "pgtbltest")
+def test_pgtbltest():
+    r.run_qemu(shell_script([
+        'pgtbltest'
+    ]), timeout=300)
+
+@test(10, "pgtbltest: ugetpid", parent=test_pgtbltest)
+def test_ugetpid_():
+    r.match('^ugetpid_test: OK$')
+
+@test(10, "pgtbltest: print_kpgtbl", parent=test_pgtbltest)
+def test_print_kpgtbl_():
+    r.match(
+        '^page table 0x',
+        '^ \.\.0x0000000000000000',
+        '^ \.\. \.\.0x0000000000000000',
+        '^ \.\. \.\. \.\.0x0000000000000000',
+        '^ \.\. \.\. \.\.0x0000000000001000',
+        '^ \.\. \.\. \.\.0x0000000000002000',
+        '^ \.\. \.\. \.\.0x0000000000003000',
+        '^ \.\.(0xffffffffc0000000|0x0000003fc0000000)',
+        '^ \.\. \.\.(0xffffffffffe00000|0x0000003fffe00000)',
+        '^ \.\. \.\. \.\.(0xffffffffffffd000|0x0000003fffffd000)',
+        '^ \.\. \.\. \.\.(0xffffffffffffe000|0x0000003fffffe000)',
+        '^ \.\. \.\. \.\.(0xfffffffffffff000|0x0000003ffffff000)',
+    )
+
+@test(15, "pgtbltest: superpg", parent=test_pgtbltest)
+def test_superpg_():
+    r.match('^superpg_test: OK$')
+
+@test(5, "answers-pgtbl.txt")
+def test_answers():
+    # just a simple sanity check, will be graded manually
+    check_answers("answers-pgtbl.txt")
+
+@test(0, "usertests")
+def test_usertests():
+    r.run_qemu(shell_script([
+        'usertests -q'
+    ]), timeout=300)
+
+@test(10, "usertests: all tests", parent=test_usertests)
+def test_usertests():
+    r.match('^ALL TESTS PASSED$')
+
+@test(1, "time")
+def test_time():
+    check_time()
+
+run_tests()
diff --git a/grade-lab-syscall b/grade-lab-syscall
deleted file mode 100755
index 928369e..0000000
--- a/grade-lab-syscall
+++ /dev/null
@@ -1,82 +0,0 @@
-#!/usr/bin/env python3
-
-import re
-from gradelib import *
-
-r = Runner(save("xv6.out"))
-
-@test(5, "answers-syscall.txt")
-def test_answers():
-    # just a simple sanity check, will be graded manually
-    check_answers("answers-syscall.txt")
-
-@test(5, "trace 32 grep")
-def test_trace_32_grep():
-    r.run_qemu(shell_script([
-        'trace 32 grep hello README'
-    ]))
-    r.match('^\\d+: syscall read -> \\d+')
-    r.match('^\\d+: syscall read -> \\d+')
-    r.match('^\\d+: syscall read -> \\d+')
-    r.match('^\\d+: syscall read -> 0')
-
-@test(5, "trace close grep")
-def test_trace_close_grep():
-    r.run_qemu(shell_script(['trace 2097152 grep hello README']))
-    r.match('^\\d+: syscall close -> 0')
-    r.match(no=[".* syscall read .*"])
-
-@test(5, "trace exec + open grep")
-def test_trace_exec_open_grep():
-    r.run_qemu(shell_script(['trace 32896 grep hello README']))
-    r.match('^\\d+: syscall exec -> 3')
-    r.match('^\\d+: syscall open -> 3')
-    r.match(no=[".* syscall read .*"])
-
-@test(5, "trace all grep")
-def test_trace_all_grep():
-    r.run_qemu(shell_script([
-        'trace 2147483647 grep hello README'
-    ]))
-    r.match('^\\d+: syscall trace -> 0')
-    r.match('^\\d+: syscall exec -> 3')
-    r.match('^\\d+: syscall open -> 3')
-    r.match('^\\d+: syscall read -> \\d+')
-    r.match('^\\d+: syscall read -> \\d+')
-    r.match('^\\d+: syscall read -> \\d+')
-    r.match('^\\d+: syscall read -> 0')
-    r.match('^\\d+: syscall close -> 0')
-
-@test(5, "trace nothing")
-def test_trace_nothing():
-    r.run_qemu(shell_script([
-        'grep hello README'
-    ]))
-    r.match(no=[".* syscall .*"])
-
-@test(5, "trace children")
-def test_trace_children():
-    r.run_qemu(shell_script([
-        'trace 2 usertests forkforkfork'
-    ]))
-    r.match('3: syscall fork -> 4')
-    r.match('^5: syscall fork -> \\d+')
-    r.match('^6: syscall fork -> \\d+')
-    r.match('^\\d+: syscall fork -> -1')
-    r.match('^OK')
-
-@test(14, "attack")
-def test_attack():
-    r.run_qemu(shell_script([
-        'attacktest'
-    ]))
-    r.match('^OK: secret is')
-
-@test(1, "time")
-def test_time():
-    check_time()
-
-run_tests()
-
-
-
diff --git a/kernel/defs.h b/kernel/defs.h
index d1b6bb9..d133cd3 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -1,3 +1,7 @@
+#ifdef LAB_MMAP
+typedef unsigned long size_t;
+typedef long int off_t;
+#endif
 struct buf;
 struct context;
 struct file;
@@ -117,6 +121,10 @@ void            initlock(struct spinlock*, char*);
 void            release(struct spinlock*);
 void            push_off(void);
 void            pop_off(void);
+int             atomic_read4(int *addr);
+#ifdef LAB_LOCK
+void            freelock(struct spinlock*);
+#endif
 
 // sleeplock.c
 void            acquiresleep(struct sleeplock*);
@@ -173,6 +181,12 @@ uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+#if defined(LAB_PGTBL) || defined(SOL_MMAP)
+void            vmprint(pagetable_t);
+#endif
+#ifdef LAB_PGTBL
+pte_t*          pgpte(pagetable_t, uint64);
+#endif
 
 // plic.c
 void            plicinit(void);
@@ -187,3 +201,39 @@ void            virtio_disk_intr(void);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+
+
+#ifdef LAB_PGTBL
+// vmcopyin.c
+int             copyin_new(pagetable_t, char *, uint64, uint64);
+int             copyinstr_new(pagetable_t, char *, uint64, uint64);
+#endif
+
+#ifdef LAB_LOCK
+// stats.c
+void            statsinit(void);
+void            statsinc(void);
+
+// sprintf.c
+int             snprintf(char*, unsigned long, const char*, ...);
+#endif
+
+#ifdef KCSAN
+void            kcsaninit();
+#endif
+
+#ifdef LAB_NET
+// pci.c
+void            pci_init();
+
+// e1000.c
+void            e1000_init(uint32 *);
+void            e1000_intr(void);
+int             e1000_transmit(char *, int);
+
+// net.c
+void            netinit(void);
+void            net_rx(char *buf, int len);
+
+#endif
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 5247b91..0699e7e 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -30,16 +30,13 @@ kinit()
   freerange(end, (void*)PHYSTOP);
 }
 
-
-
 void
 freerange(void *pa_start, void *pa_end)
 {
   char *p;
   p = (char*)PGROUNDUP((uint64)pa_start);
-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE) {
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
     kfree(p);
-  }
 }
 
 // Free the page of physical memory pointed at by pa,
@@ -54,12 +51,9 @@ kfree(void *pa)
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
-
-#ifndef LAB_SYSCALL
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
-#endif
-  
+
   r = (struct run*)pa;
 
   acquire(&kmem.lock);
@@ -68,8 +62,6 @@ kfree(void *pa)
   release(&kmem.lock);
 }
 
-
-
 // Allocate one 4096-byte page of physical memory.
 // Returns a pointer that the kernel can use.
 // Returns 0 if the memory cannot be allocated.
@@ -80,14 +72,11 @@ kalloc(void)
 
   acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r) {
+  if(r)
     kmem.freelist = r->next;
-  }
   release(&kmem.lock);
-#ifndef LAB_SYSCALL
+
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
-#endif
   return (void*)r;
 }
-
diff --git a/kernel/memlayout.h b/kernel/memlayout.h
index 3ab2ace..0a5679b 100644
--- a/kernel/memlayout.h
+++ b/kernel/memlayout.h
@@ -25,6 +25,10 @@
 #define VIRTIO0 0x10001000
 #define VIRTIO0_IRQ 1
 
+#ifdef LAB_NET
+#define E1000_IRQ 33
+#endif
+
 // qemu puts platform-level interrupt controller (PLIC) here.
 #define PLIC 0x0c000000L
 #define PLIC_PRIORITY (PLIC + 0x0)
@@ -45,7 +49,7 @@
 
 // map kernel stacks beneath the trampoline,
 // each surrounded by invalid guard pages.
-#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)
+#define KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)
 
 // User memory layout.
 // Address zero first:
@@ -54,6 +58,14 @@
 //   fixed-size stack
 //   expandable heap
 //   ...
+//   USYSCALL (shared with kernel)
 //   TRAPFRAME (p->trapframe, used by the trampoline)
 //   TRAMPOLINE (the same page as in the kernel)
 #define TRAPFRAME (TRAMPOLINE - PGSIZE)
+#ifdef LAB_PGTBL
+#define USYSCALL (TRAPFRAME - PGSIZE)
+
+struct usyscall {
+  int pid;  // Process ID
+};
+#endif
diff --git a/kernel/riscv.h b/kernel/riscv.h
index f7aaa8a..6cfff1e 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -204,7 +204,7 @@ r_menvcfg()
 static inline void 
 w_menvcfg(uint64 x)
 {
-  // asm volatile("csrw menvcfg, %0" : : "r" (x));
+  //asm volatile("csrw menvcfg, %0" : : "r" (x));
   asm volatile("csrw 0x30a, %0" : : "r" (x));
 }
 
@@ -314,6 +314,14 @@ r_sp()
   return x;
 }
 
+static inline uint64
+r_fp()
+{
+  uint64 x;
+  asm volatile("mv %0, s0" : "=r" (x) );
+  return x;
+}
+
 // read and write tp, the thread pointer, which xv6 uses to hold
 // this core's hartid (core number), the index into cpus[].
 static inline uint64
@@ -354,6 +362,11 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PGSIZE 4096 // bytes per page
 #define PGSHIFT 12  // bits of offset within a page
 
+#ifdef LAB_PGTBL
+#define SUPERPGSIZE (2 * (1 << 20)) // bytes per page
+#define SUPERPGROUNDUP(sz)  (((sz)+SUPERPGSIZE-1) & ~(SUPERPGSIZE-1))
+#endif
+
 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
 
@@ -363,6 +376,12 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
 
+
+
+#if defined(LAB_MMAP) || defined(LAB_PGTBL)
+#define PTE_LEAF(pte) (((pte) & PTE_R) | ((pte) & PTE_W) | ((pte) & PTE_X))
+#endif
+
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..4aea542 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -102,6 +102,17 @@ extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
 
+#ifdef LAB_NET
+extern uint64 sys_bind(void);
+extern uint64 sys_unbind(void);
+extern uint64 sys_send(void);
+extern uint64 sys_recv(void);
+#endif
+#ifdef LAB_PGTBL
+extern uint64 sys_pgpte(void);
+extern uint64 sys_kpgtbl(void);
+#endif
+
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
@@ -126,8 +137,20 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+#ifdef LAB_NET
+[SYS_bind] sys_bind,
+[SYS_unbind] sys_unbind,
+[SYS_send] sys_send,
+[SYS_recv] sys_recv,
+#endif
+#ifdef LAB_PGTBL
+[SYS_pgpte] sys_pgpte,
+[SYS_kpgtbl] sys_kpgtbl,
+#endif
 };
 
+
+
 void
 syscall(void)
 {
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..a122272 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,18 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+// System calls for labs
+#define SYS_trace     22
+#define SYS_sysinfo   23
+#define SYS_sigalarm  24
+#define SYS_sigreturn 25
+#define SYS_symlink   26
+#define SYS_mmap      27
+#define SYS_munmap    28
+#define SYS_bind      29
+#define SYS_unbind    30
+#define SYS_send      31
+#define SYS_recv      32
+#define SYS_pgpte     33
+#define SYS_kpgtbl    34
diff --git a/kernel/sysinfo.h b/kernel/sysinfo.h
deleted file mode 100644
index fb878e6..0000000
--- a/kernel/sysinfo.h
+++ /dev/null
@@ -1,4 +0,0 @@
-struct sysinfo {
-  uint64 freemem;   // amount of free memory (bytes)
-  uint64 nproc;     // number of process
-};
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..d9b7f9c 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -1,7 +1,7 @@
 #include "types.h"
 #include "riscv.h"
-#include "defs.h"
 #include "param.h"
+#include "defs.h"
 #include "memlayout.h"
 #include "spinlock.h"
 #include "proc.h"
@@ -54,6 +54,7 @@ sys_sleep(void)
   int n;
   uint ticks0;
 
+
   argint(0, &n);
   if(n < 0)
     n = 0;
@@ -70,6 +71,37 @@ sys_sleep(void)
   return 0;
 }
 
+
+#ifdef LAB_PGTBL
+int
+sys_pgpte(void)
+{
+  uint64 va;
+  struct proc *p;  
+
+  p = myproc();
+  argaddr(0, &va);
+  pte_t *pte = pgpte(p->pagetable, va);
+  if(pte != 0) {
+      return (uint64) *pte;
+  }
+  return 0;
+}
+#endif
+
+#ifdef LAB_PGTBL
+int
+sys_kpgtbl(void)
+{
+  struct proc *p;  
+
+  p = myproc();
+  vmprint(p->pagetable);
+  return 0;
+}
+#endif
+
+
 uint64
 sys_kill(void)
 {
diff --git a/user/attack.c b/user/attack.c
deleted file mode 100644
index 928e7d0..0000000
--- a/user/attack.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "kernel/types.h"
-#include "kernel/fcntl.h"
-#include "user/user.h"
-#include "kernel/riscv.h"
-
-int
-main(int argc, char *argv[])
-{
-  // your code here.  you should write the secret to fd 2 using write
-  // (e.g., write(2, secret, 8)
-
-  exit(1);
-}
diff --git a/user/attacktest.c b/user/attacktest.c
deleted file mode 100644
index 6853b62..0000000
--- a/user/attacktest.c
+++ /dev/null
@@ -1,107 +0,0 @@
-#include "kernel/types.h"
-#include "kernel/fcntl.h"
-#include "user/user.h"
-#include "kernel/riscv.h"
-
-char secret[8];
-char output[64];
-
-// from FreeBSD.
-int
-do_rand(unsigned long *ctx)
-{
-/*
- * Compute x = (7^5 * x) mod (2^31 - 1)
- * without overflowing 31 bits:
- *      (2^31 - 1) = 127773 * (7^5) + 2836
- * From "Random number generators: good ones are hard to find",
- * Park and Miller, Communications of the ACM, vol. 31, no. 10,
- * October 1988, p. 1195.
- */
-    long hi, lo, x;
-
-    /* Transform to [1, 0x7ffffffe] range. */
-    x = (*ctx % 0x7ffffffe) + 1;
-    hi = x / 127773;
-    lo = x % 127773;
-    x = 16807 * lo - 2836 * hi;
-    if (x < 0)
-        x += 0x7fffffff;
-    /* Transform to [0, 0x7ffffffd] range. */
-    x--;
-    *ctx = x;
-    return (x);
-}
-
-unsigned long rand_next = 1;
-
-int
-rand(void)
-{
-    return (do_rand(&rand_next));
-}
-
-// generate a random string of the indicated length.
-char *
-randstring(char *buf, int n)
-{
-  for(int i = 0; i < n-1; i++) {
-    buf[i] = "./abcdef"[(rand() >> 7) % 8];
-  }
-  if(n > 0)
-    buf[n-1] = '\0';
-  return buf;
-}
-
-int
-main(int argc, char *argv[])
-{
-  int pid;
-  int fds[2];
-
-  // an insecure way of generating a random string, because xv6
-  // doesn't have good source of randomness.
-  rand_next = uptime();
-  randstring(secret, 8);
-  
-  if((pid = fork()) < 0) {
-    printf("fork failed\n");
-    exit(1);   
-  }
-  if(pid == 0) {
-    char *newargv[] = { "secret", secret, 0 };
-    exec(newargv[0], newargv);
-    printf("exec %s failed\n", newargv[0]);
-    exit(1);
-  } else {
-    wait(0);  // wait for secret to exit
-    if(pipe(fds) < 0) {
-      printf("pipe failed\n");
-      exit(1);   
-    }
-    if((pid = fork()) < 0) {
-      printf("fork failed\n");
-      exit(1);   
-    }
-    if(pid == 0) {
-      close(fds[0]);
-      close(2);
-      dup(fds[1]);
-      char *newargv[] = { "attack", 0 };
-      exec(newargv[0], newargv);
-      printf("exec %s failed\n", newargv[0]);
-      exit(1);
-    } else {
-       close(fds[1]);
-      if(read(fds[0], output, 64) < 0) {
-        printf("FAIL; read failed; no secret\n");
-        exit(1);
-      }
-      if(strcmp(secret, output) == 0) {
-        printf("OK: secret is %s\n", output);
-      } else {
-        printf("FAIL: no/incorrect secret\n");
-      }
-    }
-  }
-}
diff --git a/user/pgtbltest.c b/user/pgtbltest.c
new file mode 100644
index 0000000..cde6e03
--- /dev/null
+++ b/user/pgtbltest.c
@@ -0,0 +1,142 @@
+#include "kernel/param.h"
+#include "kernel/fcntl.h"
+#include "kernel/types.h"
+#include "kernel/riscv.h"
+#include "user/user.h"
+
+#define N (8 * (1 << 20))
+
+void print_pgtbl();
+void print_kpgtbl();
+void ugetpid_test();
+void superpg_test();
+
+int
+main(int argc, char *argv[])
+{
+  print_pgtbl();
+  ugetpid_test();
+  print_kpgtbl();
+  superpg_test();
+  printf("pgtbltest: all tests succeeded\n");
+  exit(0);
+}
+
+char *testname = "???";
+
+void
+err(char *why)
+{
+  printf("pgtbltest: %s failed: %s, pid=%d\n", testname, why, getpid());
+  exit(1);
+}
+
+void
+print_pte(uint64 va)
+{
+    pte_t pte = (pte_t) pgpte((void *) va);
+    printf("va 0x%lx pte 0x%lx pa 0x%lx perm 0x%lx\n", va, pte, PTE2PA(pte), PTE_FLAGS(pte));
+}
+
+void
+print_pgtbl()
+{
+  printf("print_pgtbl starting\n");
+  for (uint64 i = 0; i < 10; i++) {
+    print_pte(i * PGSIZE);
+  }
+  uint64 top = MAXVA/PGSIZE;
+  for (uint64 i = top-10; i < top; i++) {
+    print_pte(i * PGSIZE);
+  }
+  printf("print_pgtbl: OK\n");
+}
+
+void
+ugetpid_test()
+{
+  int i;
+
+  printf("ugetpid_test starting\n");
+  testname = "ugetpid_test";
+
+  for (i = 0; i < 64; i++) {
+    int ret = fork();
+    if (ret != 0) {
+      wait(&ret);
+      if (ret != 0)
+        exit(1);
+      continue;
+    }
+    if (getpid() != ugetpid())
+      err("missmatched PID");
+    exit(0);
+  }
+  printf("ugetpid_test: OK\n");
+}
+
+void
+print_kpgtbl()
+{
+  printf("print_kpgtbl starting\n");
+  kpgtbl();
+  printf("print_kpgtbl: OK\n");
+}
+
+
+void
+supercheck(uint64 s)
+{
+  pte_t last_pte = 0;
+
+  for (uint64 p = s;  p < s + 512 * PGSIZE; p += PGSIZE) {
+    pte_t pte = (pte_t) pgpte((void *) p);
+    if(pte == 0)
+      err("no pte");
+    if ((uint64) last_pte != 0 && pte != last_pte) {
+        err("pte different");
+    }
+    if((pte & PTE_V) == 0 || (pte & PTE_R) == 0 || (pte & PTE_W) == 0){
+      err("pte wrong");
+    }
+    last_pte = pte;
+  }
+
+  for(int i = 0; i < 512; i += PGSIZE){
+    *(int*)(s+i) = i;
+  }
+
+  for(int i = 0; i < 512; i += PGSIZE){
+    if(*(int*)(s+i) != i)
+      err("wrong value");
+  }
+}
+
+void
+superpg_test()
+{
+  int pid;
+  
+  printf("superpg_test starting\n");
+  testname = "superpg_test";
+  
+  char *end = sbrk(N);
+  if (end == 0 || end == (char*)0xffffffffffffffff)
+    err("sbrk failed");
+  
+  uint64 s = SUPERPGROUNDUP((uint64) end);
+  supercheck(s);
+  if((pid = fork()) < 0) {
+    err("fork");
+  } else if(pid == 0) {
+    supercheck(s);
+    exit(0);
+  } else {
+    int status;
+    wait(&status);
+    if (status != 0) {
+      exit(0);
+    }
+  }
+  printf("superpg_test: OK\n");  
+}
diff --git a/user/secret.c b/user/secret.c
deleted file mode 100644
index 77378f4..0000000
--- a/user/secret.c
+++ /dev/null
@@ -1,20 +0,0 @@
-#include "kernel/types.h"
-#include "kernel/fcntl.h"
-#include "user/user.h"
-#include "kernel/riscv.h"
-
-
-int
-main(int argc, char *argv[])
-{
-  if(argc != 2){
-    printf("Usage: secret the-secret\n");
-    exit(1);
-  }
-  char *end = sbrk(PGSIZE*32);
-  end = end + 9 * PGSIZE;
-  strcpy(end, "my very very very secret pw is:   ");
-  strcpy(end+32, argv[1]);
-  exit(0);
-}
-
diff --git a/user/sysinfotest.c b/user/sysinfotest.c
deleted file mode 100644
index a92d10a..0000000
--- a/user/sysinfotest.c
+++ /dev/null
@@ -1,153 +0,0 @@
-#include "kernel/types.h"
-#include "kernel/riscv.h"
-#include "kernel/sysinfo.h"
-#include "user/user.h"
-
-
-void
-sinfo(struct sysinfo *info) {
-  if (sysinfo(info) < 0) {
-    printf("FAIL: sysinfo failed");
-    exit(1);
-  }
-}
-
-//
-// use sbrk() to count how many free physical memory pages there are.
-//
-int
-countfree()
-{
-  uint64 sz0 = (uint64)sbrk(0);
-  struct sysinfo info;
-  int n = 0;
-
-  while(1){
-    if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
-      break;
-    }
-    n += PGSIZE;
-  }
-  sinfo(&info);
-  if (info.freemem != 0) {
-    printf("FAIL: there is no free mem, but sysinfo.freemem=%ld\n",
-      info.freemem);
-    exit(1);
-  }
-  sbrk(-((uint64)sbrk(0) - sz0));
-  return n;
-}
-
-void
-testmem() {
-  struct sysinfo info;
-  uint64 n = countfree();
-  
-  sinfo(&info);
-
-  if (info.freemem!= n) {
-    printf("FAIL: free mem %ld (bytes) instead of %ld\n", info.freemem, n);
-    exit(1);
-  }
-  
-  if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
-    printf("sbrk failed");
-    exit(1);
-  }
-
-  sinfo(&info);
-    
-  if (info.freemem != n-PGSIZE) {
-    printf("FAIL: free mem %ld (bytes) instead of %ld\n", n-PGSIZE, info.freemem);
-    exit(1);
-  }
-  
-  if((uint64)sbrk(-PGSIZE) == 0xffffffffffffffff){
-    printf("sbrk failed");
-    exit(1);
-  }
-
-  sinfo(&info);
-    
-  if (info.freemem != n) {
-    printf("FAIL: free mem %ld (bytes) instead of %ld\n", n, info.freemem);
-    exit(1);
-  }
-}
-
-void
-testcall() {
-  struct sysinfo info;
-  
-  if (sysinfo(&info) < 0) {
-    printf("FAIL: sysinfo failed\n");
-    exit(1);
-  }
-
-  if (sysinfo((struct sysinfo *) 0xeaeb0b5b00002f5e) !=  0xffffffffffffffff) {
-    printf("FAIL: sysinfo succeeded with bad argument\n");
-    exit(1);
-  }
-}
-
-void testproc() {
-  struct sysinfo info;
-  uint64 nproc;
-  int status;
-  int pid;
-  
-  sinfo(&info);
-  nproc = info.nproc;
-
-  pid = fork();
-  if(pid < 0){
-    printf("sysinfotest: fork failed\n");
-    exit(1);
-  }
-  if(pid == 0){
-    sinfo(&info);
-    if(info.nproc != nproc+1) {
-      printf("sysinfotest: FAIL nproc is %ld instead of %ld\n", info.nproc, nproc+1);
-      exit(1);
-    }
-    exit(0);
-  }
-  wait(&status);
-  sinfo(&info);
-  if(info.nproc != nproc) {
-      printf("sysinfotest: FAIL nproc is %ld instead of %ld\n", info.nproc, nproc);
-      exit(1);
-  }
-}
-
-void testbad() {
-  int pid = fork();
-  int xstatus;
-  
-  if(pid < 0){
-    printf("sysinfotest: fork failed\n");
-    exit(1);
-  }
-  if(pid == 0){
-      sinfo(0x0);
-      exit(0);
-  }
-  wait(&xstatus);
-  if(xstatus == -1)  // kernel killed child?
-    exit(0);
-  else {
-    printf("sysinfotest: testbad succeeded %d\n", xstatus);
-    exit(xstatus);
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-  printf("sysinfotest: start\n");
-  testcall();
-  testmem();
-  testproc();
-  printf("sysinfotest: OK\n");
-  exit(0);
-}
diff --git a/user/trace.c b/user/trace.c
deleted file mode 100644
index 474b26c..0000000
--- a/user/trace.c
+++ /dev/null
@@ -1,29 +0,0 @@
-#include "kernel/param.h"
-#include "kernel/types.h"
-#include "kernel/stat.h"
-#include "user/user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-  char *nargv[MAXARG];
-
-  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
-    fprintf(2, "Usage: %s mask command\n", argv[0]);
-    exit(1);
-  }
-
-  if (trace(atoi(argv[1])) < 0) {
-    fprintf(2, "%s: trace failed\n", argv[0]);
-    exit(1);
-  }
-  
-  for(i = 2; i < argc && i < MAXARG; i++){
-    nargv[i-2] = argv[i];
-  }
-  nargv[argc-2] = 0;
-  exec(nargv[0], nargv);
-  printf("trace: exec failed\n");
-  exit(0);
-}
diff --git a/user/ulib.c b/user/ulib.c
index 0064846..324d06b 100644
--- a/user/ulib.c
+++ b/user/ulib.c
@@ -1,8 +1,13 @@
 #include "kernel/types.h"
 #include "kernel/stat.h"
 #include "kernel/fcntl.h"
+#ifdef LAB_PGTBL
+#include "kernel/riscv.h"
+#include "kernel/memlayout.h"
+#endif
 #include "user/user.h"
 
+
 //
 // wrapper so that it's OK if main() does not call exit().
 //
@@ -145,3 +150,12 @@ memcpy(void *dst, const void *src, uint n)
 {
   return memmove(dst, src, n);
 }
+
+#ifdef LAB_PGTBL
+int
+ugetpid(void)
+{
+  struct usyscall *u = (struct usyscall *)USYSCALL;
+  return u->pid;
+}
+#endif
diff --git a/user/user.h b/user/user.h
index f16fe27..b91fd89 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,3 +1,7 @@
+#ifdef LAB_MMAP
+typedef unsigned long size_t;
+typedef long int off_t;
+#endif
 struct stat;
 
 // system calls
@@ -22,6 +26,17 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+#ifdef LAB_NET
+int bind(uint32);
+int unbind(uint32);
+int send(uint32, uint32, uint32, char *, uint32);
+int recv(uint32, uint32*, uint32*, char *, uint32);
+#endif
+#ifdef LAB_PGTBL
+int ugetpid(void);
+uint64 pgpte(void*);
+void kpgtbl(void);
+#endif
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -37,6 +52,9 @@ void* memset(void*, int, uint);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+#ifdef LAB_LOCK
+int statistics(void*, int);
+#endif
 
 // umalloc.c
 void* malloc(uint);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..2c19fa6 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,9 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("bind");
+entry("unbind");
+entry("send");
+entry("recv");
+entry("pgpte");
+entry("kpgtbl");
