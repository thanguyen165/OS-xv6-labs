diff --git a/README b/README
index 5a5d695..f583201 100644
--- a/README
+++ b/README
@@ -31,9 +31,6 @@ Rafael Ubal, Amane Uehara, Pablo Ventura, Xi Wang, WaheedHafez,
 Keiichi Watanabe, Lucas Wolf, Nicolas Wolovick, wxdao, Grant Wu, x653,
 Jindong Zhang, Icenowy Zheng, ZhUyU1997, and Zou Chang Wei.
 
-The code in the files that constitute xv6 is
-Copyright 2006-2024 Frans Kaashoek, Robert Morris, and Russ Cox.
-
 ERROR REPORTS
 
 Please send errors and suggestions to Frans Kaashoek and Robert Morris
diff --git a/conf/lab.mk b/conf/lab.mk
index 05e8b8d..278d1a8 100644
--- a/conf/lab.mk
+++ b/conf/lab.mk
@@ -1 +1 @@
-LAB=util
+LAB=syscall
diff --git a/grade-lab-syscall b/grade-lab-syscall
new file mode 100755
index 0000000..928369e
--- /dev/null
+++ b/grade-lab-syscall
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+
+import re
+from gradelib import *
+
+r = Runner(save("xv6.out"))
+
+@test(5, "answers-syscall.txt")
+def test_answers():
+    # just a simple sanity check, will be graded manually
+    check_answers("answers-syscall.txt")
+
+@test(5, "trace 32 grep")
+def test_trace_32_grep():
+    r.run_qemu(shell_script([
+        'trace 32 grep hello README'
+    ]))
+    r.match('^\\d+: syscall read -> \\d+')
+    r.match('^\\d+: syscall read -> \\d+')
+    r.match('^\\d+: syscall read -> \\d+')
+    r.match('^\\d+: syscall read -> 0')
+
+@test(5, "trace close grep")
+def test_trace_close_grep():
+    r.run_qemu(shell_script(['trace 2097152 grep hello README']))
+    r.match('^\\d+: syscall close -> 0')
+    r.match(no=[".* syscall read .*"])
+
+@test(5, "trace exec + open grep")
+def test_trace_exec_open_grep():
+    r.run_qemu(shell_script(['trace 32896 grep hello README']))
+    r.match('^\\d+: syscall exec -> 3')
+    r.match('^\\d+: syscall open -> 3')
+    r.match(no=[".* syscall read .*"])
+
+@test(5, "trace all grep")
+def test_trace_all_grep():
+    r.run_qemu(shell_script([
+        'trace 2147483647 grep hello README'
+    ]))
+    r.match('^\\d+: syscall trace -> 0')
+    r.match('^\\d+: syscall exec -> 3')
+    r.match('^\\d+: syscall open -> 3')
+    r.match('^\\d+: syscall read -> \\d+')
+    r.match('^\\d+: syscall read -> \\d+')
+    r.match('^\\d+: syscall read -> \\d+')
+    r.match('^\\d+: syscall read -> 0')
+    r.match('^\\d+: syscall close -> 0')
+
+@test(5, "trace nothing")
+def test_trace_nothing():
+    r.run_qemu(shell_script([
+        'grep hello README'
+    ]))
+    r.match(no=[".* syscall .*"])
+
+@test(5, "trace children")
+def test_trace_children():
+    r.run_qemu(shell_script([
+        'trace 2 usertests forkforkfork'
+    ]))
+    r.match('3: syscall fork -> 4')
+    r.match('^5: syscall fork -> \\d+')
+    r.match('^6: syscall fork -> \\d+')
+    r.match('^\\d+: syscall fork -> -1')
+    r.match('^OK')
+
+@test(14, "attack")
+def test_attack():
+    r.run_qemu(shell_script([
+        'attacktest'
+    ]))
+    r.match('^OK: secret is')
+
+@test(1, "time")
+def test_time():
+    check_time()
+
+run_tests()
+
+
+
diff --git a/grade-lab-util b/grade-lab-util
deleted file mode 100755
index 9ba6e37..0000000
--- a/grade-lab-util
+++ /dev/null
@@ -1,105 +0,0 @@
-#!/usr/bin/env python3
-
-import re
-from gradelib import *
-
-r = Runner(save("xv6.out"))
-
-@test(5, "sleep, no arguments")
-def test_sleep_no_args():
-    r.run_qemu(shell_script([
-        'sleep'
-    ]))
-    r.match(no=["exec .* failed", "$ sleep\n$"])
-
-@test(5, "sleep, returns")
-def test_sleep_no_args():
-    r.run_qemu(shell_script([
-        'sleep',
-        'echo OK'
-    ]))
-    r.match('^OK$', no=["exec .* failed", "$ sleep\n$"])
-
-@test(10, "sleep, makes syscall")
-def test_sleep():
-    r.run_qemu(shell_script([
-        'sleep 10',
-        'echo FAIL'
-    ]), stop_breakpoint('sys_sleep'))
-    r.match('\\$ sleep 10', no=['FAIL'])
-
-@test(20, "pingpong")
-def test_pingpong():
-    r.run_qemu(shell_script([
-        'pingpong', 'echo OK'
-    ]))
-    r.match('^\\d+: received ping$', '^\\d+: received pong$', '^OK$')
-
-@test(20, "primes")
-def test_primes():
-    r.run_qemu(shell_script([
-        'primes', 'echo OK'
-    ]))
-    args = ['prime %d' % i for i in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269]]
-    args.append('^OK$')
-    r.match(*args)
-
-@test(10, "find, in current directory")
-def test_find_curdir():
-    fn = random_str()
-    r.run_qemu(shell_script([
-        'echo > %s' % fn,
-        'find . %s' % fn
-    ]))
-    r.match('./%s' % fn)
-    r.match(no=["./README", "README"])
-
-@test(10, "find, in sub-directory")
-def test_find_curdir():
-    dd = random_str()
-    fn = random_str()
-    r.run_qemu(shell_script([
-        'echo > %s' % fn,
-        'mkdir %s' % dd,
-        'echo > %s/%s' % (dd, fn),
-        'find %s %s' % (dd, fn)
-    ]))
-    r.match('%s/%s' % (dd, fn))
-    r.match(no=['./%s' % fn])
-
-@test(10, "find, recursive")
-def test_find_recursive():
-    needle = random_str()
-    dirs = [random_str() for _ in range(3)]
-    r.run_qemu(shell_script([
-        'mkdir %s' % dirs[0],
-        'echo > %s/%s' % (dirs[0], needle),
-        'mkdir %s/%s' % (dirs[0], dirs[1]),
-        'echo > %s/%s/%s' % (dirs[0], dirs[1], needle),
-        'mkdir %s' % dirs[2],
-        'echo > %s/%s' % (dirs[2], needle),
-        'find . %s' % needle
-    ]))
-    r.match('./%s/%s' % (dirs[0], needle),
-            './%s/%s/%s' % (dirs[0], dirs[1], needle),
-            './%s/%s' % (dirs[2], needle))
-
-@test(10, "xargs")
-def test_xargs():
-    r.run_qemu(shell_script([
-        'sh < xargstest.sh',
-        'echo DONE',
-    ], 'DONE'))
-    matches = re.findall("hello", r.qemu.output)
-    assert_equal(len(matches), 3, "Number of appearances of 'hello'")
-
-@test(9, "xargs, multi-line echo")
-def test_xargs_multiline():
-    r.run_qemu(shell_script(['(echo 1 ; echo 2) | xargs echo']))
-    r.match('^1$', '^2$')
-
-@test(1, "time")
-def test_time():
-    check_time()
-    
-run_tests()
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..5247b91 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -30,13 +30,16 @@ kinit()
   freerange(end, (void*)PHYSTOP);
 }
 
+
+
 void
 freerange(void *pa_start, void *pa_end)
 {
   char *p;
   p = (char*)PGROUNDUP((uint64)pa_start);
-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE) {
     kfree(p);
+  }
 }
 
 // Free the page of physical memory pointed at by pa,
@@ -51,9 +54,12 @@ kfree(void *pa)
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
+
+#ifndef LAB_SYSCALL
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
-
+#endif
+  
   r = (struct run*)pa;
 
   acquire(&kmem.lock);
@@ -62,6 +68,8 @@ kfree(void *pa)
   release(&kmem.lock);
 }
 
+
+
 // Allocate one 4096-byte page of physical memory.
 // Returns a pointer that the kernel can use.
 // Returns 0 if the memory cannot be allocated.
@@ -72,11 +80,14 @@ kalloc(void)
 
   acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
+  if(r) {
     kmem.freelist = r->next;
+  }
   release(&kmem.lock);
-
+#ifndef LAB_SYSCALL
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
+#endif
   return (void*)r;
 }
+
diff --git a/kernel/param.h b/kernel/param.h
index 07e6f17..80ec6d3 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -1,8 +1,4 @@
-#ifdef LAB_FS
-#define NPROC        10  // maximum number of processes
-#else
-#define NPROC        64  // maximum number of processes (speedsup bigfile)
-#endif
+#define NPROC        64  // maximum number of processes
 #define NCPU          8  // maximum number of CPUs
 #define NOFILE       16  // open files per process
 #define NFILE       100  // open files per system
@@ -13,21 +9,7 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#ifdef LAB_FS
-#define FSSIZE       200000  // size of file system in blocks
-#else
-#ifdef LAB_LOCK
-#define FSSIZE       10000  // size of file system in blocks
-#else
-#define FSSIZE       2000   // size of file system in blocks
-#endif
-#endif
+#define FSSIZE       2000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
-
-#ifdef LAB_UTIL
-#define USERSTACK    2     // user stack pages
-#else
 #define USERSTACK    1     // user stack pages
-#endif
-
 
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 6cfff1e..f7aaa8a 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -204,7 +204,7 @@ r_menvcfg()
 static inline void 
 w_menvcfg(uint64 x)
 {
-  //asm volatile("csrw menvcfg, %0" : : "r" (x));
+  // asm volatile("csrw menvcfg, %0" : : "r" (x));
   asm volatile("csrw 0x30a, %0" : : "r" (x));
 }
 
@@ -314,14 +314,6 @@ r_sp()
   return x;
 }
 
-static inline uint64
-r_fp()
-{
-  uint64 x;
-  asm volatile("mv %0, s0" : "=r" (x) );
-  return x;
-}
-
 // read and write tp, the thread pointer, which xv6 uses to hold
 // this core's hartid (core number), the index into cpus[].
 static inline uint64
@@ -362,11 +354,6 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PGSIZE 4096 // bytes per page
 #define PGSHIFT 12  // bits of offset within a page
 
-#ifdef LAB_PGTBL
-#define SUPERPGSIZE (2 * (1 << 20)) // bytes per page
-#define SUPERPGROUNDUP(sz)  (((sz)+SUPERPGSIZE-1) & ~(SUPERPGSIZE-1))
-#endif
-
 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
 
@@ -376,12 +363,6 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
 
-
-
-#if defined(LAB_MMAP) || defined(LAB_PGTBL)
-#define PTE_LEAF(pte) (((pte) & PTE_R) | ((pte) & PTE_W) | ((pte) & PTE_X))
-#endif
-
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/kernel/sysinfo.h b/kernel/sysinfo.h
new file mode 100644
index 0000000..fb878e6
--- /dev/null
+++ b/kernel/sysinfo.h
@@ -0,0 +1,4 @@
+struct sysinfo {
+  uint64 freemem;   // amount of free memory (bytes)
+  uint64 nproc;     // number of process
+};
diff --git a/kernel/vm.c b/kernel/vm.c
index 62421a2..7f388fe 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -4,6 +4,8 @@
 #include "elf.h"
 #include "riscv.h"
 #include "defs.h"
+#include "spinlock.h"
+#include "proc.h"
 #include "fs.h"
 
 /*
@@ -30,6 +32,14 @@ kvmmake(void)
   // virtio mmio disk interface
   kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
 
+#ifdef LAB_NET
+  // PCI-E ECAM (configuration space), for pci.c
+  kvmmap(kpgtbl, 0x30000000L, 0x30000000L, 0x10000000, PTE_R | PTE_W);
+
+  // pci.c maps the e1000's registers here.
+  kvmmap(kpgtbl, 0x40000000L, 0x40000000L, 0x20000, PTE_R | PTE_W);
+#endif  
+
   // PLIC
   kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);
 
@@ -92,6 +102,11 @@ walk(pagetable_t pagetable, uint64 va, int alloc)
     pte_t *pte = &pagetable[PX(level, va)];
     if(*pte & PTE_V) {
       pagetable = (pagetable_t)PTE2PA(*pte);
+#ifdef LAB_PGTBL
+      if(PTE_LEAF(*pte)) {
+        return pte;
+      }
+#endif
     } else {
       if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
         return 0;
@@ -125,6 +140,7 @@ walkaddr(pagetable_t pagetable, uint64 va)
   return pa;
 }
 
+
 // add a mapping to the kernel page table.
 // only used when booting.
 // does not flush TLB or enable paging.
@@ -179,15 +195,19 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 {
   uint64 a;
   pte_t *pte;
+  int sz;
 
   if((va % PGSIZE) != 0)
     panic("uvmunmap: not aligned");
 
-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+  for(a = va; a < va + npages*PGSIZE; a += sz){
+    sz = PGSIZE;
     if((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
+    if((*pte & PTE_V) == 0) {
+      printf("va=%ld pte=%ld\n", a, *pte);
       panic("uvmunmap: not mapped");
+    }
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
     if(do_free){
@@ -227,6 +247,7 @@ uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
   memmove(mem, src, sz);
 }
 
+
 // Allocate PTEs and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 uint64
@@ -234,19 +255,23 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
 {
   char *mem;
   uint64 a;
+  int sz;
 
   if(newsz < oldsz)
     return oldsz;
 
   oldsz = PGROUNDUP(oldsz);
-  for(a = oldsz; a < newsz; a += PGSIZE){
+  for(a = oldsz; a < newsz; a += sz){
+    sz = PGSIZE;
     mem = kalloc();
     if(mem == 0){
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+#ifndef LAB_SYSCALL
+    memset(mem, 0, sz);
+#endif
+    if(mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
       kfree(mem);
       uvmdealloc(pagetable, a, oldsz);
       return 0;
@@ -316,8 +341,11 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   uint64 pa, i;
   uint flags;
   char *mem;
+  int szinc;
 
-  for(i = 0; i < sz; i += PGSIZE){
+  for(i = 0; i < sz; i += szinc){
+    szinc = PGSIZE;
+    szinc = PGSIZE;
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
@@ -363,13 +391,21 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
-    if(va0 >= MAXVA)
+    if (va0 >= MAXVA)
+      return -1;
+    if((pte = walk(pagetable, va0, 0)) == 0) {
+      // printf("copyout: pte should exist 0x%x %d\n", dstva, len);
+      return -1;
+    }
+
+
+    // forbid copyout over read-only user text pages.
+    if((*pte & PTE_W) == 0)
       return -1;
-    pte = walk(pagetable, va0, 0);
-    if(pte == 0 || (*pte & PTE_V) == 0 || (*pte & PTE_U) == 0 ||
-       (*pte & PTE_W) == 0)
+    
+    pa0 = walkaddr(pagetable, va0);
+    if(pa0 == 0)
       return -1;
-    pa0 = PTE2PA(*pte);
     n = PGSIZE - (dstva - va0);
     if(n > len)
       n = len;
@@ -389,7 +425,7 @@ int
 copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 {
   uint64 n, va0, pa0;
-
+  
   while(len > 0){
     va0 = PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
@@ -449,3 +485,20 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+
+#ifdef LAB_PGTBL
+void
+vmprint(pagetable_t pagetable) {
+  // your code here
+}
+#endif
+
+
+
+#ifdef LAB_PGTBL
+pte_t*
+pgpte(pagetable_t pagetable, uint64 va) {
+  return walk(pagetable, va, 0);
+}
+#endif
diff --git a/user/attack.c b/user/attack.c
new file mode 100644
index 0000000..928e7d0
--- /dev/null
+++ b/user/attack.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "kernel/fcntl.h"
+#include "user/user.h"
+#include "kernel/riscv.h"
+
+int
+main(int argc, char *argv[])
+{
+  // your code here.  you should write the secret to fd 2 using write
+  // (e.g., write(2, secret, 8)
+
+  exit(1);
+}
diff --git a/user/attacktest.c b/user/attacktest.c
new file mode 100644
index 0000000..6853b62
--- /dev/null
+++ b/user/attacktest.c
@@ -0,0 +1,107 @@
+#include "kernel/types.h"
+#include "kernel/fcntl.h"
+#include "user/user.h"
+#include "kernel/riscv.h"
+
+char secret[8];
+char output[64];
+
+// from FreeBSD.
+int
+do_rand(unsigned long *ctx)
+{
+/*
+ * Compute x = (7^5 * x) mod (2^31 - 1)
+ * without overflowing 31 bits:
+ *      (2^31 - 1) = 127773 * (7^5) + 2836
+ * From "Random number generators: good ones are hard to find",
+ * Park and Miller, Communications of the ACM, vol. 31, no. 10,
+ * October 1988, p. 1195.
+ */
+    long hi, lo, x;
+
+    /* Transform to [1, 0x7ffffffe] range. */
+    x = (*ctx % 0x7ffffffe) + 1;
+    hi = x / 127773;
+    lo = x % 127773;
+    x = 16807 * lo - 2836 * hi;
+    if (x < 0)
+        x += 0x7fffffff;
+    /* Transform to [0, 0x7ffffffd] range. */
+    x--;
+    *ctx = x;
+    return (x);
+}
+
+unsigned long rand_next = 1;
+
+int
+rand(void)
+{
+    return (do_rand(&rand_next));
+}
+
+// generate a random string of the indicated length.
+char *
+randstring(char *buf, int n)
+{
+  for(int i = 0; i < n-1; i++) {
+    buf[i] = "./abcdef"[(rand() >> 7) % 8];
+  }
+  if(n > 0)
+    buf[n-1] = '\0';
+  return buf;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int pid;
+  int fds[2];
+
+  // an insecure way of generating a random string, because xv6
+  // doesn't have good source of randomness.
+  rand_next = uptime();
+  randstring(secret, 8);
+  
+  if((pid = fork()) < 0) {
+    printf("fork failed\n");
+    exit(1);   
+  }
+  if(pid == 0) {
+    char *newargv[] = { "secret", secret, 0 };
+    exec(newargv[0], newargv);
+    printf("exec %s failed\n", newargv[0]);
+    exit(1);
+  } else {
+    wait(0);  // wait for secret to exit
+    if(pipe(fds) < 0) {
+      printf("pipe failed\n");
+      exit(1);   
+    }
+    if((pid = fork()) < 0) {
+      printf("fork failed\n");
+      exit(1);   
+    }
+    if(pid == 0) {
+      close(fds[0]);
+      close(2);
+      dup(fds[1]);
+      char *newargv[] = { "attack", 0 };
+      exec(newargv[0], newargv);
+      printf("exec %s failed\n", newargv[0]);
+      exit(1);
+    } else {
+       close(fds[1]);
+      if(read(fds[0], output, 64) < 0) {
+        printf("FAIL; read failed; no secret\n");
+        exit(1);
+      }
+      if(strcmp(secret, output) == 0) {
+        printf("OK: secret is %s\n", output);
+      } else {
+        printf("FAIL: no/incorrect secret\n");
+      }
+    }
+  }
+}
diff --git a/user/secret.c b/user/secret.c
new file mode 100644
index 0000000..77378f4
--- /dev/null
+++ b/user/secret.c
@@ -0,0 +1,20 @@
+#include "kernel/types.h"
+#include "kernel/fcntl.h"
+#include "user/user.h"
+#include "kernel/riscv.h"
+
+
+int
+main(int argc, char *argv[])
+{
+  if(argc != 2){
+    printf("Usage: secret the-secret\n");
+    exit(1);
+  }
+  char *end = sbrk(PGSIZE*32);
+  end = end + 9 * PGSIZE;
+  strcpy(end, "my very very very secret pw is:   ");
+  strcpy(end+32, argv[1]);
+  exit(0);
+}
+
diff --git a/user/sysinfotest.c b/user/sysinfotest.c
new file mode 100644
index 0000000..a92d10a
--- /dev/null
+++ b/user/sysinfotest.c
@@ -0,0 +1,153 @@
+#include "kernel/types.h"
+#include "kernel/riscv.h"
+#include "kernel/sysinfo.h"
+#include "user/user.h"
+
+
+void
+sinfo(struct sysinfo *info) {
+  if (sysinfo(info) < 0) {
+    printf("FAIL: sysinfo failed");
+    exit(1);
+  }
+}
+
+//
+// use sbrk() to count how many free physical memory pages there are.
+//
+int
+countfree()
+{
+  uint64 sz0 = (uint64)sbrk(0);
+  struct sysinfo info;
+  int n = 0;
+
+  while(1){
+    if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
+      break;
+    }
+    n += PGSIZE;
+  }
+  sinfo(&info);
+  if (info.freemem != 0) {
+    printf("FAIL: there is no free mem, but sysinfo.freemem=%ld\n",
+      info.freemem);
+    exit(1);
+  }
+  sbrk(-((uint64)sbrk(0) - sz0));
+  return n;
+}
+
+void
+testmem() {
+  struct sysinfo info;
+  uint64 n = countfree();
+  
+  sinfo(&info);
+
+  if (info.freemem!= n) {
+    printf("FAIL: free mem %ld (bytes) instead of %ld\n", info.freemem, n);
+    exit(1);
+  }
+  
+  if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
+    printf("sbrk failed");
+    exit(1);
+  }
+
+  sinfo(&info);
+    
+  if (info.freemem != n-PGSIZE) {
+    printf("FAIL: free mem %ld (bytes) instead of %ld\n", n-PGSIZE, info.freemem);
+    exit(1);
+  }
+  
+  if((uint64)sbrk(-PGSIZE) == 0xffffffffffffffff){
+    printf("sbrk failed");
+    exit(1);
+  }
+
+  sinfo(&info);
+    
+  if (info.freemem != n) {
+    printf("FAIL: free mem %ld (bytes) instead of %ld\n", n, info.freemem);
+    exit(1);
+  }
+}
+
+void
+testcall() {
+  struct sysinfo info;
+  
+  if (sysinfo(&info) < 0) {
+    printf("FAIL: sysinfo failed\n");
+    exit(1);
+  }
+
+  if (sysinfo((struct sysinfo *) 0xeaeb0b5b00002f5e) !=  0xffffffffffffffff) {
+    printf("FAIL: sysinfo succeeded with bad argument\n");
+    exit(1);
+  }
+}
+
+void testproc() {
+  struct sysinfo info;
+  uint64 nproc;
+  int status;
+  int pid;
+  
+  sinfo(&info);
+  nproc = info.nproc;
+
+  pid = fork();
+  if(pid < 0){
+    printf("sysinfotest: fork failed\n");
+    exit(1);
+  }
+  if(pid == 0){
+    sinfo(&info);
+    if(info.nproc != nproc+1) {
+      printf("sysinfotest: FAIL nproc is %ld instead of %ld\n", info.nproc, nproc+1);
+      exit(1);
+    }
+    exit(0);
+  }
+  wait(&status);
+  sinfo(&info);
+  if(info.nproc != nproc) {
+      printf("sysinfotest: FAIL nproc is %ld instead of %ld\n", info.nproc, nproc);
+      exit(1);
+  }
+}
+
+void testbad() {
+  int pid = fork();
+  int xstatus;
+  
+  if(pid < 0){
+    printf("sysinfotest: fork failed\n");
+    exit(1);
+  }
+  if(pid == 0){
+      sinfo(0x0);
+      exit(0);
+  }
+  wait(&xstatus);
+  if(xstatus == -1)  // kernel killed child?
+    exit(0);
+  else {
+    printf("sysinfotest: testbad succeeded %d\n", xstatus);
+    exit(xstatus);
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+  printf("sysinfotest: start\n");
+  testcall();
+  testmem();
+  testproc();
+  printf("sysinfotest: OK\n");
+  exit(0);
+}
diff --git a/user/trace.c b/user/trace.c
new file mode 100644
index 0000000..474b26c
--- /dev/null
+++ b/user/trace.c
@@ -0,0 +1,29 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  char *nargv[MAXARG];
+
+  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
+    fprintf(2, "Usage: %s mask command\n", argv[0]);
+    exit(1);
+  }
+
+  if (trace(atoi(argv[1])) < 0) {
+    fprintf(2, "%s: trace failed\n", argv[0]);
+    exit(1);
+  }
+  
+  for(i = 2; i < argc && i < MAXARG; i++){
+    nargv[i-2] = argv[i];
+  }
+  nargv[argc-2] = 0;
+  exec(nargv[0], nargv);
+  printf("trace: exec failed\n");
+  exit(0);
+}
diff --git a/user/xargstest.sh b/user/xargstest.sh
deleted file mode 100644
index 4362589..0000000
--- a/user/xargstest.sh
+++ /dev/null
@@ -1,6 +0,0 @@
-mkdir a
-echo hello > a/b
-mkdir c
-echo hello > c/b
-echo hello > b
-find . b | xargs grep hello
